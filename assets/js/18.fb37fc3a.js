(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{218:function(n,t,r){"use strict";r.r(t);var e=r(0),i=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"箭头函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),r("h2",{attrs:{id:"es6标准新增了一种新的函数：arrow-function（箭头函数）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es6标准新增了一种新的函数：arrow-function（箭头函数）"}},[n._v("#")]),n._v(" ES6标准新增了一种新的函数：Arrow Function（箭头函数）")]),n._v(" "),r("pre",[r("code",[n._v("1. 为什么叫Arrow Function？因为它的定义用的就是一个箭头：\n    x => x * x\n2. 上面的箭头函数相当于：\n    function (x) {\n        return x * x;\n    }\n3. 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一\n个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{...}\n和return：\n    x => {\n        if (x > 0) {\n            return x * x;\n        }\n        else {\n            return - x * x;\n        }\n    }\n4. 如果参数不是一个，就需要用括号()括起来：\n    1⃣️ 两个参数:\n        (x, y) => x * x + y * y\n    2⃣️ 无参数:\n        () => 3.14\n    3⃣️ 可变参数:\n        (x, y, ...rest) => {\n            var i, sum = x + y;\n            for (i=0; i<rest.length; i++) {\n                sum += rest[i];\n            }\n            return sum;\n        }\n5. 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：\n    1⃣️ SyntaxError:\n        x => { foo: x }\n    2⃣️ 因为和函数体的{ ... }有语法冲突，所以要改为：\n        x => ({ foo: x })\n")])]),n._v(" "),r("h2",{attrs:{id:"this"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[n._v("#")]),n._v(" this")]),n._v(" "),r("pre",[r("code",[n._v("箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内\n部的this是词法作用域，由上下文确定。\n1.回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：\n    var obj = {\n        birth: 1990,\n        getAge: function () {\n            var b = this.birth; // 1990\n            var fn = function () {\n                return new Date().getFullYear() - this.birth; // this指向window或undefined\n            };\n            return fn();\n        }\n    };\n2. 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：\n    var obj = {\n        birth: 1990,\n        getAge: function () {\n            var b = this.birth; // 1990\n            var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\n            return fn();\n        }\n    };\n    obj.getAge(); // 25\n3. 如果使用箭头函数，以前的那种hack写法：\n    var that = this;\n    就不再需要了。\n\n4. 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数\n时，无法对this进行绑定，即传入的第一个参数被忽略：\n    var obj = {\n        birth: 1990,\n        getAge: function (year) {\n            var b = this.birth; // 1990\n            var fn = (y) => y - this.birth; // this.birth仍是1990\n            return fn.call({birth:2000}, year);\n        }\n    };\n    obj.getAge(2015); // 25\n")])])])}),[],!1,null,null,null);t.default=i.exports}}]);